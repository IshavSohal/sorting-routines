/********************************************************************************
 *                                                                              *
 * Author: Ishav Sohal                                                          *
 * Class: ICS 4U                                                                *
 * Date: February 3rd, 2020                                                     *                     
 * Program: Sorting Routines                                                    *
 * Description: This program will allow the user to create an array consisting  *
 *              of random numbers between -1000 and 1000. The user chooses the  *
 *              length of this array. The user is then able to sort this array, *
 *              using one of four sorting algorithms: Selection Sort, Insertion *
 *              Sort, Bubble Sort and Quick Sort. The user is also able to      *
 *              choose whether they want the array to be sorted in ascending or *
 *              descending order                                                *
 *                                                                              *
 *******************************************************************************/

// Imports the required Java libraries/classes
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Random;
import java.util.Arrays;

public class Sorting_Routines extends javax.swing.JFrame {

    // Creates new form "Sorting_Routines" 
    public Sorting_Routines() {
        initComponents();
        
        // Creates an Action Listener for the "AlgorithmSelection" Combo Box
        AlgorithmSelection.addActionListener (new ActionListener(){

            // Method that executes code for when this Combo Box is modified
            public void actionPerformed (ActionEvent e){
                
                // Puts the currenly selected option of this combo box into the "txtSortingAlgorithm Text Field
                txtSortingAlgorithm.setText (AlgorithmSelection.getSelectedItem().toString());
                
                // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
                txtArrayNums.requestFocusInWindow();
            }
        });
        
        // Creates an Action Listener for the "OrderSelection" Combo Box
        OrderSelection.addActionListener (new ActionListener(){
            
            // Method that executes code for when this Combo Box is modified
            public void actionPerformed (ActionEvent e){
                
                // Puts the currenly selected option of this combo box into the "txtSortOrder Text Field
                txtSortOrder.setText (OrderSelection.getSelectedItem().toString());
                
                // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
                txtArrayNums.requestFocusInWindow();
            }
        });

        // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
        txtArrayNums.requestFocusInWindow();
        
        // Makes the "txtSortingAlgorithm" text field invisible
        txtSortingAlgorithm.setVisible(false);
        
        // Makes the "txtSortOrder" text field invisible
        txtSortOrder.setVisible(false);
 
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        labelTitle = new javax.swing.JLabel();
        labelInfo = new javax.swing.JLabel();
        labelAlgorithm = new javax.swing.JLabel();
        labelOrder = new javax.swing.JLabel();
        labelArrayNums = new javax.swing.JLabel();
        labelOriginalArray = new javax.swing.JLabel();
        labelSortedArray = new javax.swing.JLabel();
        labelError = new javax.swing.JLabel();
        btnSort = new javax.swing.JButton();
        txtArrayNums = new javax.swing.JTextField();
        txtOriginalArray = new javax.swing.JTextField();
        txtSortOrder = new javax.swing.JTextField();
        txtSortingAlgorithm = new javax.swing.JTextField();
        txtSortedArray = new javax.swing.JTextField();
        btnCreateArray = new javax.swing.JButton();
        AlgorithmSelection = new javax.swing.JComboBox<>();
        OrderSelection = new javax.swing.JComboBox<>();
        btnExit = new javax.swing.JButton();
        btnClear = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setPreferredSize(new java.awt.Dimension(760, 600));

        labelTitle.setFont(new java.awt.Font("Haettenschweiler", 0, 64)); // NOI18N
        labelTitle.setForeground(new java.awt.Color(255, 102, 0));
        labelTitle.setText("Sorting Routines");

        labelInfo.setFont(new java.awt.Font("Verdana", 0, 20)); // NOI18N
        labelInfo.setText("Enter the following information: ");

        labelAlgorithm.setFont(new java.awt.Font("Tahoma", 0, 20)); // NOI18N
        labelAlgorithm.setText("Sorting Algorithm: ");

        labelOrder.setFont(new java.awt.Font("Tahoma", 0, 20)); // NOI18N
        labelOrder.setText("Sort Order: ");

        labelArrayNums.setFont(new java.awt.Font("Tahoma", 0, 20)); // NOI18N
        labelArrayNums.setText("Amount of numbers within Array: ");

        labelOriginalArray.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        labelOriginalArray.setText("Original Array: ");

        labelSortedArray.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        labelSortedArray.setText("Sorted Array: ");

        labelError.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        labelError.setForeground(new java.awt.Color(255, 0, 0));

        btnSort.setBackground(new java.awt.Color(0, 153, 255));
        btnSort.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        btnSort.setText("Sort");
        btnSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSortActionPerformed(evt);
            }
        });

        txtArrayNums.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        txtArrayNums.setHorizontalAlignment(javax.swing.JTextField.CENTER);

        txtOriginalArray.setEditable(false);
        txtOriginalArray.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        txtSortOrder.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        txtSortOrder.setHorizontalAlignment(javax.swing.JTextField.CENTER);

        txtSortingAlgorithm.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        txtSortingAlgorithm.setHorizontalAlignment(javax.swing.JTextField.CENTER);

        txtSortedArray.setEditable(false);
        txtSortedArray.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        btnCreateArray.setBackground(new java.awt.Color(255, 153, 0));
        btnCreateArray.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        btnCreateArray.setText("Create Array");
        btnCreateArray.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCreateArrayActionPerformed(evt);
            }
        });

        AlgorithmSelection.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        AlgorithmSelection.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "No Selection", "Selection Sort", "Insertion Sort", "Bubble Sort", "Quick Sort" }));

        OrderSelection.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        OrderSelection.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "No Selection", "Ascending", "Descending" }));

        btnExit.setBackground(new java.awt.Color(255, 0, 0));
        btnExit.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        btnExit.setText("Exit");
        btnExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExitActionPerformed(evt);
            }
        });

        btnClear.setBackground(new java.awt.Color(0, 204, 0));
        btnClear.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        btnClear.setText("Clear");
        btnClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(labelSortedArray)
                                    .addComponent(labelOriginalArray))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 5, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(txtOriginalArray, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 635, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(txtSortedArray, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 635, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(labelAlgorithm)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(AlgorithmSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 153, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(txtSortingAlgorithm, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                                        .addGap(60, 60, 60)
                                        .addComponent(labelOrder)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(txtSortOrder, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(OrderSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 153, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(labelArrayNums)
                                                .addGap(31, 31, 31)
                                                .addComponent(txtArrayNums, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addComponent(labelError, javax.swing.GroupLayout.PREFERRED_SIZE, 467, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGap(69, 69, 69)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(btnCreateArray, javax.swing.GroupLayout.DEFAULT_SIZE, 157, Short.MAX_VALUE)
                                            .addComponent(btnSort, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                                .addGap(0, 0, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(196, 196, 196)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(labelInfo)
                            .addComponent(labelTitle))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(btnClear, javax.swing.GroupLayout.PREFERRED_SIZE, 151, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnExit, javax.swing.GroupLayout.PREFERRED_SIZE, 151, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(190, 190, 190))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addComponent(labelTitle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(labelInfo)
                .addGap(43, 43, 43)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(labelAlgorithm)
                            .addComponent(labelOrder)
                            .addComponent(AlgorithmSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(OrderSelection, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtSortingAlgorithm, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtSortOrder, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(26, 26, 26)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnCreateArray, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtArrayNums, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(labelArrayNums, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(28, 28, 28)
                        .addComponent(labelError, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(btnSort, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(30, 30, 30)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtOriginalArray, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labelOriginalArray))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelSortedArray)
                    .addComponent(txtSortedArray, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 28, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnExit, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnClear, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(22, 22, 22))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    // Code Stub for "btnSort" - Executed when the user clicks the "Sort" button
    private void btnSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSortActionPerformed

        // Stores the current text of the "txtSortingAlgorithm" text field in the variable "algorithm_selected"
        String algorithm_selected = txtSortingAlgorithm.getText();

        // Stores the current text of the "txtSortOrder" text field in the variable "option_selected"
        String option_selected = txtSortOrder.getText();
        
        // If the user does not choose a Sort Option and a Sorting Algorithm
        if (option_selected.equals ("") && algorithm_selected.equals ("")){
            
            // Tells the user to choose an available Sorting Algorithm and Sort Option
            labelError.setText("Please choose an available Sorting Algorithm and Sort Option ");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
            
        }

        // Else, if the user does not choose a Sorting Algorithm or a Sort Option
        else if (algorithm_selected.equals ("No Selection") && option_selected.equals ("No Selection")){
            
            // Tells the user to choose an available Sorting Algorithm and Sort Option
            labelError.setText("Please choose an available Sorting Algorithm and Sort Option ");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
        }
        
        // Else, if the user does not choose a Sorting Algorithm, but chooses a Sort Option
        else if (algorithm_selected.equals ("No Selection") && !option_selected.equals ("No Selection")){
            
            // Tells the user to choose an available Sorting Algorithm and Sort Option
            labelError.setText("Please choose an available Sorting Algorithm");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
        }
        
        // Else, if the user does not choose a Sort Option, but chooses a Sorting Algorithm
        else if (!algorithm_selected.equals ("No Selection") && option_selected.equals ("No Selection")){
            
            // Tells the user to choose an available Sorting Algorithm and Sort Option
            labelError.setText("Please choose an available Sort Option");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
        }
        
        
        // Else, if the user does not choose a Sorting Algorithm, but chooses a Sort Option
        else if (algorithm_selected.equals ("") && !option_selected.equals ("")){
            
            // Tells the user to choose an available Sorting Algorithm
            labelError.setText("Please choose an available Sorting Algorithm");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();

        }
        
        // Else, if the user does not choose a Sort Option, but chooses a Sorting Algorithm
        else if (option_selected.equals ("")&& !algorithm_selected.equals ("")){
            
            // Tells the user to choose an available Sort Option
            labelError.setText("Please choose an available Sort Option");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();

        }

        
        /* Else, if the original array is created, and the user has selected both a Sorting 
        Algorithm and a Sort Option, then execute the following code */
        else if (!txtOriginalArray.getText().equals("") && !option_selected.equals ("") && !algorithm_selected.equals ("")){

            // Stores the original array in the variable "arr"
            String arr = txtOriginalArray.getText();
            
            // Converts the string "arr" it into a String Array, called "items",. which consists of numbers 
            String[] items = arr.replaceAll("\\[", "").replaceAll("\\]", "").replaceAll("\\s", "").split(",");

            // Creates an Integer Array, called "array_nums", which is the same length as the String Array "items"
            int[] array_nums = new int[items.length];

            // Creates a for loop, which adds values to the "array_nums" Integer Array
            for (int i = 0; i < items.length; i++) {
               
                // Converts each value of the "items" String Array to an Integer, and puts it into the array "array_nums"
                array_nums[i] = Integer.parseInt(items[i]);
               
            }


            // If the user chose to sort the array in ascending order
            if (option_selected.equals("Ascending")){

                // If the user chose the Selection Sort Algroithm to sort the array
                if (algorithm_selected.equals ("Selection Sort")){

                    /* Call the "SelectionSort_Ascending" method, with "array_nums" in 
                    its parameter. This function will sort the "array_nums" array in 
                    ascending order (least to greatest) using the Selection Sort Algorithm, 
                    and will store the sorted array in the array "sorted_array" */
                    int sorted_array [] = SelectionSort_Ascending (array_nums);
                    
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (sorted_array));

                }

                // If the user chose the Insertion Sort Algroithm to sort the array
                else if (algorithm_selected.equals ("Insertion Sort")){

                    /* Call the "InsertionSort_Ascending" method, with "array_nums" 
                    in its parameter. This function will sort the "array_nums" array 
                    in ascending order (least to greatest) using the Insertion Sort 
                    Algorithm, and will store the sorted array in the array "sorted_array" */
                    int sorted_array [] = InsertionSort_Ascending (array_nums);
                    
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (sorted_array));

                }

                // If the user chose the Bubble Sort Algroithm to sort the array
                else if (algorithm_selected.equals ("Bubble Sort")){

                    /* Call the "BubbleSort_Ascending" method, with "array_nums" in its 
                    parameter. This function will sort the "array_nums" array in ascending 
                    order (least to greatest) using the Bubble Sort Algorithm, and will 
                    store the sorted array in the array "sorted_array" */
                    int sorted_array [] = BubbleSort_Ascending (array_nums);
                    
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (sorted_array));

                }

                // If the user chose the Quick Sort Algroithm to sort the array
                else if (algorithm_selected.equals ("Quick Sort")){

                    /* Call the "QuickSort_Ascending" method, with "array_nums", the first 
                    and the last index positions of the "array_nums" array in its parameter.
                    This function will sort the "array_nums" array in ascending order 
                    (least to greatest) using the Quick Sort Algorithm */
                    QuickSort_Ascending (array_nums, 0, array_nums.length - 1);
                    
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (array_nums));
                    
                }
            }
            
            // If the user chose to sort the array in descending order
            else if (option_selected.equals("Descending")){

                // If the user chose the Selection Sort Algroithm to sort the array
                if (algorithm_selected.equals ("Selection Sort")){

                    /* Call the "SelectionSort_Descending" method, with "array_nums" in its 
                    parameter. This function will sort the "array_nums" array in descending 
                    order (greatest to least) using the Selection Sort Algorithm, and will 
                    store the sorted array in the array "sorted_array" */
                    int sorted_array [] = SelectionSort_Descending (array_nums);
                    
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (sorted_array));

                }

                // If the user chose the Insertion Sort Algroithm to sort the array
                else if (algorithm_selected.equals ("Insertion Sort")){
                    
                    /* Call the "InsertionSort_Descending" method, with "array_nums" in 
                    its parameter. This function will sort the "array_nums" array in 
                    descending order (greatest to least) using the Insertion Sort Algorithm, 
                    and will store the sorted array in the array "sorted_array" */
                    int sorted_array [] = InsertionSort_Descending (array_nums);
                   
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (sorted_array));
                }

                // If the user chose the Bubble Sort Algroithm to sort the array
                else if (algorithm_selected.equals ("Bubble Sort")){

                    /* Call the "BubbleSort_Descending" method, with "array_nums" in its 
                    parameter. This function will sort the "array_nums" array in descending
                    order (greatest to least) using the Bubble Sort Algorithm, and will store 
                    the sorted array in the array "sorted_array" */
                    int sorted_array [] = BubbleSort_Descending (array_nums);
                   
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (sorted_array));

                }

                // If the user chose the Quick Sort Algroithm to sort the array
                else if (algorithm_selected.equals ("Quick Sort")){

                    /* Call the "QuickSort_Descending" method, with "array_nums", the first
                    and the last index positions of the "array_nums" array in its parameter. 
                    This function will sort the "array_nums" array in descending order 
                    (greatest to least) using the Quick Sort Algorithm */
                    QuickSort_Descending (array_nums, 0, array_nums.length - 1);
                   
                    // Sets the text of the "txtSortedArray" text field to the sorted array
                    txtSortedArray.setText (Arrays.toString (array_nums));

                }
            }
            
            // Clears the "labelError" label
            labelError.setText("");
            
        }
        
        // Else, if the original array currently does not exist 
        else {
            
            // Tells the user that they have not created an array to sort yet
            labelError.setText ("There is no array to sort. Please create an array, and try again.");
           
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
        }

    }//GEN-LAST:event_btnSortActionPerformed

    // Code Stub for "btnCreateArray" - Executed when the user clicks the "Create Array" button
    private void btnCreateArrayActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCreateArrayActionPerformed

        /* If the user enters a valid array length value. The user must enter an array 
        length value that is between 0 and 18. The array created cannot have 0 elements, 
        because it will have no values to sort. The array created can only have up to 
        18 elements, because any number of elements greater than 18 will not fit onto the screen. */
        if (txtArrayNums.getText().matches("[0-9]+") && Integer.parseInt(txtArrayNums.getText())<= 18 && Integer.parseInt(txtArrayNums.getText()) > 0){

            // Stores the users array length value as an integer, in the variable "array_values" 
            int array_values = Integer.parseInt(txtArrayNums.getText());
           
            // Creates an Integer Array, called "array_nums" which has a length defined by the user 
            int array_nums [] = new int [array_values];

            // Creates a random variable, called "r"
            Random r = new Random (); 
            
            /* Creates a variable called "low", and sets it to -1000. This variable holds
            the minimum value that can be within the "array_nums" array */
            int low = -1000;
           
            /* Creates a variable called "high", and sets it to 1000. This variable holds
            the maximum value that can be within the "array_nums" array */
            int high = 1000;

            // Creates a for loop, which assigns a value to each index position of the "array_nums" array
            for (int x = 0; x < array_nums.length; x ++){
               
                // Sets each index position of the "array_nums" array to a random value between -1000 and 1000
                array_nums[x] = r.nextInt(high-low)+ low;
            }
            
            // Puts the "array_nums" array in the "txtOriginalArray" text field 
            txtOriginalArray.setText(Arrays.toString(array_nums));
            
            // Clears the "labelError" label
            labelError.setText("");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
            
            // Clears the "txtSortedArray" text field, so it is ready to store the next sorted array 
            txtSortedArray.setText("");
        }
        
        // Else, if the user does not choose a valid array length value 
        else {
            
            // Tells the user to enter a valid array length value 
            labelError.setText ("Please enter a valid array length value, and try again");
            
            // Clears the "txtArrayNums" text field 
            txtArrayNums.setText("");
            
            // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
            txtArrayNums.requestFocusInWindow();
            
        }

    }//GEN-LAST:event_btnCreateArrayActionPerformed

    // Code Stub for "btnExit" - Executed when the user clicks the "Exit" button
    private void btnExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExitActionPerformed
    
        // Exits the program
        System.exit(0);
        
    }//GEN-LAST:event_btnExitActionPerformed

    // Code Stub for "btnClear" - Executed when the user clicks the "Clear" button
    private void btnClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearActionPerformed
        
        // Clears all text fields and labels of the array
        txtArrayNums.setText ("");
        txtOriginalArray.setText("");
        txtSortedArray.setText("");
        labelError.setText("");
        
        // Sets the cursor to the "txtArrayNums" text field, so it is ready for the user to type in 
        txtArrayNums.requestFocusInWindow();
    }//GEN-LAST:event_btnClearActionPerformed

    
    // A method to sort an array, using a Selection Sort algorithm, in ascending order
    public static int [] SelectionSort_Ascending (int [] array1){

        /* Accesses each index position of "array_1", except for the last index position. 
        This is because once the loop is on the last index psoition, all of the the other 
        indexes will already be in order fromm least to greatest, so the value in the last 
        index will automatically be the largest value, so there is no need to sort that. 
        This loop essentially goes through the unsorted elements of the array, while 
        skipping over the sorted elements */
        for (int x = 0; x < (array1.length) - 1; x++){
            
            /* Sets the index position "x", which holds the first unsorted element, 
            as the minimum value */
            int min = x;
            
            // Accesses each index position after the first unsorted element
            for (int j = x + 1; j < array1.length; j++){
                
                /* If the value of array1 at index "j" is less than the value of the 
                array at the current minimuim value */
                if (array1[j] < array1[min]){
                    
                    // Sets the index position "j" as the minimum values index 
                    min = j;
                }
            }
            
            // If the minimim value is not equal to the first unsorted element
            if (min != x){

                /* Swaps the minimum unsorted value with the first unsorted value. This 
                is done by first, storing the minimum value in a variable called "temp",
                then setting the value of the current minimum value of the array to the 
                value of the first unsorted element, and finally setting the value at the 
                index position of "x" to "temp". This will essentially put the minimum 
                unsorted element in the beginning of the array. */
                int temp = array1[min];
                array1[min] = array1[x];
                array1[x] = temp;
            }
        }
        
        // Returns the sorted array to the point where this function was called
        return array1;
    }
    
    // A method to sort an array, using a Selection Sort algorithm, in descending order
    public static int [] SelectionSort_Descending (int [] array1){
        
        /* Accesses each index position of "array_1", except for the last index position, 
        This is because once the loop is on the last index psoition, all of the the other
        indexes will already be in order from greatest to least, so the value in the last 
        index will automatically be the smallest value, so there is no need to sort that. 
        This loop essentially goes through the unsorted elements of the array, while skipping
        over the sorted elements */
        for (int x = 0; x < (array1.length) - 1; x++){
            
            // Sets the index position "x", which holds the first unsorted element, as the maximum value 
            int max = x;
            
            // Accesses each index position after the first unsorted element
            for (int j = x + 1; j < array1.length; j++){
                
                /* If the value of array1 at index "j" is greater than the current maximum value of 
                the array */
                if (array1[j] > array1[max]){
                    
                    // Sets the index position "j" as the maximum values index 
                    max = j;
                }
            }
            
            // If the current maximum value of the array is not equal to the first unsorted element
            if (max != x){

                /* Swaps the maximum unsorted value with the first unsorted element. This 
                is done by first, storing the maximum value in a variable called "temp", 
                then setting the value of the current maximum value of the array to the 
                value of the first unsorted element, and finally setting the value at the 
                index position of "x" to "temp". This will essentially put the maximum 
                unsorted element in the beginning of the array, each time the loop is executed */
                int temp = array1[max];
                array1[max] = array1[x];
                array1[x] = temp;
            }
        }
        
        // Returns the sorted array to the point where this function was called
        return array1;
    }
    
    // A method to sort an array, using a Insertion Sort algorithm, in ascending order
    public static int [] InsertionSort_Ascending (int [] array1){
    
        /* Accesses each value within the array "array1". This for loop will sort this array
        in ascending order (from least to greatest). It will do so by having two portions
        of the array, the sorted section and the unsorted section. This for loop will move 
        array elements from the unsorted section of the array to the sorted section of the
        array. The values entered into the sorted section will be placed in the location 
        which allows the sorted section to be in ascending order. Values from the unsorted
        section will be added to the sorted section, until all values have been sorted. Also, 
        the first value of the array is not accessed, due to the fact that it is automatically 
        placed into the sorted section of the array, and the remaining values of the array are 
        placed into the sorted section according to the initial value. */
        for (int x = 1; x < array1.length; x++){
            
            // Stores the current value of the array in "element"
            int element = array1[x];
            
            // Stores the current index position in "j"
            int j = x;
            
            /* While j is greater than 0, and the previous array value is greater than the 
            current array value, execute this code. This while loop will essentially shift 
            the array values that are larger than the current array value to the right, so 
            a gap can be opened for the current array value to be moved from the unsorted 
            section of the array to the sorted section of the array. Once the previous value
            of the array is less than the current value, or the beginning of the array is 
            reached,the while loop will stop executing, and the current value will be placed 
            in the position that it currently is in, which would be to the right of the value
            smaller than it, or at the very first index position of the array */
            while (j > 0 && array1[j-1] > element){
                
                /* Sets the array value at index "j" equal to the array value to the left of it.
                Essentially, this will shift every array value greater than the current value of
                the array to the right, so a place can be opened up for the current value of the 
                array to be placed in the correct position in the sorted portion of the array */
                array1[j] = array1[j - 1];
                
                /* Subtracts "j" by 1. This is done in order to access each value behind
                the current value, and compare them in order to determine where to place the 
                current value within the sorted portion of the array */
                j --;
            }
            
            /* Sets the correct index position of the array to the current value of the array
            This will essentially place the current value of the array in its correct position
            within the sorted portion of the array. */
            array1[j] = element; 
        }
        
        // Returns the sorted array to the point where this function was called
        return array1;
    }
    
    // A method to sort an array, using a Insertion Sort algorithm, in descending order    
    public static int [] InsertionSort_Descending (int [] array1){
        
        /* Accesses each value within the array "array1". This for loop will sort this array
        in descending order (from greatest to least). It will do so by having two portions
        of the array, the sorted section and the unsorted section. This for loop will move 
        array elements from the unsorted section of the array to the sorted section of the
        array. The values entered into the sorted section will be placed in the location 
        which allows the sorted section to be in descending order. Values from the unsorted
        section will be added to the sorted section, until all values have been sorted. Also, 
        the first value of the array is not accessed, due to the fact that it is automatically 
        placed into the sorted section of the array, and the remaining values of the array are 
        placed into the sorted section according to the initial value. */
        for (int x = 1; x < array1.length; x++){
            
            // Stores the current value of the array in "element"
            int element = array1[x];
            
            // Stores the current index position in "j"
            int j = x;
            
            /* While j is greater than 0,and the previous array value is less than the 
            current array value, execute this code. This while loop will essentially shift 
            the array values that are less than the current array value to the right, so 
            a gap can be opened for the current array value to be moved from the unsorted 
            section of the array to the sorted section of the array. Once the previous value
            of the array is greater than the current value, or the beginning of the array is 
            reached, the while loop will stop executing, and the current value will be placed 
            in the position that it currently is in, which would be to the right of the value 
            greater than it,  or at the very first index position of the array */
            while (j > 0 && array1[j-1] < element){
                
                /* Sets the array value at index "j" equal to the array value to the left of it
                Essentially, this will shift every array value less than the current value of
                the array to the right, so a place can be opened up for the current value of the 
                array to be placed in the correct position in the sorted portion of the array */
                array1[j] = array1[j - 1];
                
                /* Subtracts "j" by 1. This is done in order to access each value behind
                the current value, and compare them in order to determine where to place the 
                current value within the sorted portion of the array */
                j --;
            }
            
            /* Sets the correct index position of the array to the current value of the array
            This will essentially place the current value of the array in the correct position
            within the sorted section of the array. */
            array1[j] = element; 
        }   
        
        // Returns the sorted array to the point where this function was called
        return array1;
    }
    
    // A method to sort an array, using a Bubble Sort algorithm, in ascending order
    public static int [] BubbleSort_Ascending (int [] array1){
        
        /* Creates a Boolean variable called "swap", and sets it to true.
        The purpose of this variable is to track if any swaps have occured
        within the array when a passthrough of the array occurs when sorting the
        array. If no swaps occur during a specific passthrough of the array, that 
        means that the array is already fully sorted.  */
        Boolean swap = true;
        
        /* Creates an integer variable called "counter". This variable represents the
        amount of values of the end of the array that should be excluded fromm being 
        counted. */
        int counter = 0; 
       
        /*  While the value of "swap" is true, execute the following code. Essentially,
        when the value of "swap" remains true after one passthorugh of the array, that
        means that a swap of two values has occured during this passthrough. If no swaps
        occur during a specific passthrough, "swap" will be false, meaing that this while
        loop will stop running. This would occur when the array has been fully sorted in
        ascending order, and no more swaps are nessesary */
        while (swap){

            /* Sets "swap" to false, in the case that no values get swapped during a specific   
            passthrough of the array */
            swap = false;
            
            /* Increments "counter" by 1. Each time the below for loop is executed, one entire passthrough of the 
            array occurs. Every time a passthrough of the array occurs, the length of the array checked 
            decreases by 1. This is due to the fact that after the first passthrough of the array, the 
            largest value in the array is placed at the end of the array, meaning it is already in its sorted 
            position, so it does not have to be checked again. When the next passthrough of the array occurs, 
            we check every value of the array except for the last value. We then place the next largest value 
            of the array to the left of the largest value. This would continue on until all of the values in
            the array are sorted, and the amount of values checked within each passthrough of the array will 
            decrease to 1. */
            counter ++;
            
            /* Accesses each value of the array, except for the largest values that are placed at 
            the end of the array after each passthrough of the array. This for loop will compare one 
            value of the array to the value to its right. The last index position is not accessed 
            because when the second last index position of the array is accessed, it is compared to
            the last value of the array, so there is no need to access the last value indiviually.
            Also, if the last value of the array  were to be accessed individually, then the index 
            position it would be compared to would be out of range. */
            for (int x = 0; x < array1.length - counter; x ++){

                // Sets the current value of the array to "current"
                int current = array1[x];
                
                // Sets the value to the right of the current value of the array to "next"
                int next = array1[x + 1];

                /* If the current value of the array is greater than the value to the right of it */ 
                if (current > next){
                   
                    // Swaps the two values, so the smaller value is to the left of the larger value
                    int temp = current;
                    array1[x] = array1[x + 1];
                    array1[x + 1] = temp;
                   
                    // Sets swap to true, to indicate that a swap of two values has occured 
                    swap = true;
                }
            }
        }
        
        // Returns the sorted array to the point where this function was called
        return array1;
    }
    
    // A method to sort an array, using a Bubble Sort algorithm, in descending order
    public static int [] BubbleSort_Descending (int [] array1){
        
        /* Creates a Boolean variable called "swap", and sets it to true.
        The purpose of this variable is to track if any swaps have occured
        within the array when a passthrough of the array occurs when sorting the
        array. If no swaps occur during a specific passthrough of the array, that 
        means that the array is already fully sorted.  */
        Boolean swap = true;
        
        /* Creates an integer variable called "counter". This variable represents the
        amount of values of the end of the array that should be excluded fromm being 
        counted. */
        int counter = 0; 
       
        /*  While the value of "swap" is true, execute the following code. Essentially,
        when the value of "swap" remains true after one passthrough of the array, that
        means that a swap of two values has occured during this passthrough. If no swaps
        occur during a specific passthrough, "swap" will be false, meaing that this while
        loop will stop running. This would occur when the array has been fully sorted in
        ascending order, and no more swaps are nessesary */
        while (swap){

            /* Sets "swap" to false, in the case that no values get swapped during a specific   
            passthrough of the array */
            swap = false;
            
            /* Increments "counter" by 1. Each time the below for loop is executed, one entire passthrough of the 
            array occurs. Every time a passthrough of the array occurs, the length of the array checked 
            decreases by 1. This is due to the fact that after the first passthrough of the array, the 
            smallest value in the array is placed at the end of the array, meaning it is already in its sorted 
            position, so it does not have to be checked again. When the next passthrough of the array occurs, 
            we check every value of the array except for the last value. We then place the next smallest value 
            of the array to the left of the smallest value. This would continue on until all of the values in
            the array are sorted, and the amount of values checked within each passthrough of the array will 
            decrease to 1. */
            counter ++;
            
            /* Accesses each value of the array, except for the smallest values that are placed at 
            the end of the array after each passthrough of the array. This for loop will compare one 
            value of the array to the value to its right. The last index position is not accessed 
            because when the second last index position of the array is accessed, it is compared to
            the last value of the array, so there is no need to access the last value indiviually.
            Also, if the last value of the array  were to be accessed individually, then the index 
            position it would be compared to would be out of range. */
            for (int x = 0; x < array1.length - counter; x ++){

                // Sets the current value of the array to "current"
                int current = array1[x];
                
                // Sets the value to the right of the current value of the array to "next"
                int next = array1[x + 1];

                /* If the current value of the array is less than the value to the right of it */ 
                if (current < next){
                   
                    // Swaps the two values, so the larger value is to the left of the smaller value
                    int temp = current;
                    array1[x] = array1[x + 1];
                    array1[x + 1] = temp;
                   
                    // Sets swap to true, to indicate that a swap of two values has occured 
                    swap = true;
                }
            }
        }
        
        // Returns the sorted array to the point where this function was called
        return array1;
    }

    
    /* Creates a method called "QuickSort_Ascending", which takes 3 parameters; the array we want sorted,
    the rightmost value and the leftmost value. This method will use a quick sort algorithm to 
    sort an array in ascending order. First, it will choose a pivot value, which is the middle 
    value of the array. It will then put all of the values in the array that are less than the 
    pivot value on the left side of the pivot value. It will also put all of the values in the 
    array that are greater than the pivot value on the right side of the pivot value. The array
    will then be split up into two subarrays, which are the values to the left of the pivot, and 
    the values to the right of the pivot. The same process is applied to these two subarrays, 
    and this will recursively continue until the entire array is sorted, which is when the 
    subarrays created each have a length of 1 */
    public static void QuickSort_Ascending (int[] array1, int left, int right){  
       
        /* Sets "i" to the leftmost index position of the array/subarray being observed 
        This variable will be used to access each value to the left of the pivot value */
        int i = left; 
        
        /* Sets "j" to the leftmost index position of the array/subarray being observed 
         This variable will be used to access each value to the right of the pivot value*/
        int j = right;  
        
        // Creates an int variable "temp" that is used for swapping two values
        int temp; 
        
        // Sets the pivot value to the middle index position of the array/subarray
        int pivot = array1[(left+right)/2]; 
        
        // While index "i" is less than/equal to index "j", execute this code 
        while (i <= j) {  
            
            /* While the current left value of the array, which is defined by the index "i", is less 
            than the pivot value, execute the following code. Essentially, when the current left value of 
            the array is less than the pivot, move on to the next left value, as this left value is in its
            correct location within the array, which is to the left of the pivot. Values to the left of the
            pivot are meant to be less than the pivot, so if the current left value of the array is less than
            the pivot, it is in its correct place in the array. Once the current left value of the array is
            greater than the pivot, the "i" index position will stay on that left value, as it must be moved
            to the right of the pivot. */
            while (array1[i] < pivot) {
               
                //  Move the left value of the array up by 1. 
                i++;  
            }
             /* While the current right value of the array, which is defined by the index "j", is greater 
            than the pivot value, execute the following code. Essentially, when the current right value of 
            the array is greater than the pivot, move on to the next right value, as this right value is in its
            correct location within the array, which is to the right of the pivot. Values to the right of the
            pivot are meant to be greater than the pivot, so if the current right value of the array is greater than
            the pivot, it is in its correct place in the array. Once the current right value of the array is
            less than the pivot, the "j" index position will stay on that right value, as it must be moved
            to the left of the pivot.  */           
            while (array1[j] > pivot) { 
                
                // Move the right value of the array down by 1
                j--;
            }
            
            /* If the current left values index position is less than/equal to the current right values index 
            position, execute the code */
            if (i <= j) {  
                
                /*  Swap the curenrt left value with the current right value. At this point, the current left 
                value of the array is greater than/equal to the pivot, and the current right value of the array is less
                than/equal to the pivot, so these two values must be swapped in order for them to be in their correct 
                locations within the array */
                temp = array1[i];
                array1[i] = array1[j];
                array1[j] = temp;
                
                // Move onto the next left and right values in the array
                i++;
                j--;
            }
        }
        
        /* If the current right values index is greater than the leftmost values index, then call the quicksort 
        method again, but this time only accessing a subarray of the previous array, and now sorting that.
        This wil essentially sort the subarray that is to the left of the pivot. */
        if (left < j){  
            QuickSort_Ascending(array1, left, j);
        }
        
        /* If the current left values index is less than the rightmost values index, then call the quicksort 
        method again, but this time only accessing a subarray of the previous array, and now sorting that.
        This wil essentially sort the subarray that is to the right of the pivot. */
        if (i < right) {
            QuickSort_Ascending (array1, i, right);
        }

    }
    
    /* Creates a method called "QuickSort_Descending", which takes 3 parameters; the array we want sorted,
    the rightmost value and the leftmost value. This method will use a quick sort algorithm to 
    sort an array in descending order. First, it will choose a pivot value, which is the middle 
    value of the array. It will then put all of the values in the array that are greater than the 
    pivot value on the left side of the pivot value. It will also put all of the values in the 
    array that are less than the pivot value on the right side of the pivot value. The array
    will then be split up into two subarrays, which are the values to the left of the pivot, and 
    the values to the right of the pivot. The same process is applied to these two subarrays, 
    and this will recursively continue until the entire array is sorted, which is when the 
    subarrays created each have a length of 1 */
    public static void QuickSort_Descending (int[] array1, int left, int right){  
       
        /* Sets "i" to the leftmost index position of the array/subarray being observed 
        This variable will be used to access each value to the left of the pivot value */
        int i = left; 
        
        /* Sets "j" to the leftmost index position of the array/subarray being observed 
         This variable will be used to access each value to the right of the pivot value*/
        int j = right;  
        
        // Creates an int variable "temp" that is used for swapping two values
        int temp; 
        
        // Sets the pivot value to the middle index position of the array/subarray
        int pivot = array1[(left+right)/2]; 
        
        // While index "i" is less than/equal to index "j", execute this code 
        while (i <= j) {  
            
            /* While the current left value of the array, which is defined by the index "i", is greater 
            than the pivot value, execute the following code. Essentially, when the current left value of 
            the array is greater than the pivot, move on to the next left value, as this left value is in its
            correct location within the array, which is to the left of the pivot. Values to the left of the
            pivot are meant to be greater than the pivot, so if the current left value of the array is greater than
            the pivot, it is in its correct place in the array. Once the current left value of the array is
            less than the pivot, the "i" index position will stay on that left value, as it must be moved
            to the right of the pivot. */
            while (array1[i] > pivot) {
               
                //  Move the left value of the array up by 1. 
                i++;  
            }
             /* While the current right value of the array, which is defined by the index "j", is less 
            than the pivot value, execute the following code. Essentially, when the current right value of 
            the array is less than the pivot, move on to the next right value, as this right value is in its
            correct location within the array, which is to the right of the pivot. Values to the right of the
            pivot are meant to be less than the pivot, so if the current right value of the array is less than
            the pivot, it is in its correct place in the array. Once the current right value of the array is
            greater than the pivot, the "j" index position will stay on that right value, as it must be moved
            to the left of the pivot.  */           
            while (array1[j] < pivot) { 
                
                // Move the right value of the array down by 1
                j--;
            }
            
            /* If the current left values index position is less than/equal to the current right values index 
            position, execute the code */
            if (i <= j) {  
                
                /*  Swap the curenrt left value with the current right value. At this point, the current left 
                value of the array is less than the pivot, and the current right value of the array is greater
                than the pivot, so these two values must be swapped in order for them to be in their correct 
                locations within the array */
                temp = array1[i];
                array1[i] = array1[j];
                array1[j] = temp;
                
                // Move onto the next left and right values in the array
                i++;
                j--;
            }
        }
        
        /* If the current right values index is greater than the leftmost values index, then call the quicksort 
        method again, but this time only accessing a subarray of the previous array, and now sorting that.
        This wil essentially sort the subarray that is to the left of the pivot. */
        if (left < j){  
            QuickSort_Descending(array1, left, j);
        }
        
        /* If the current left values index is less than the rightmost values index, then call the quicksort 
        method again, but this time only accessing a subarray of the previous array, and now sorting that.
        This wil essentially sort the subarray that is to the right of the pivot. */
        if (i < right) {
            QuickSort_Descending (array1, i, right);
        }
    }
    
    // MAIN METHOD
    public static void main(String args[]) {


        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Sorting_Routines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Sorting_Routines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Sorting_Routines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Sorting_Routines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Sorting_Routines().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> AlgorithmSelection;
    private javax.swing.JComboBox<String> OrderSelection;
    private javax.swing.JButton btnClear;
    private javax.swing.JButton btnCreateArray;
    private javax.swing.JButton btnExit;
    private javax.swing.JButton btnSort;
    private javax.swing.JLabel labelAlgorithm;
    private javax.swing.JLabel labelArrayNums;
    private javax.swing.JLabel labelError;
    private javax.swing.JLabel labelInfo;
    private javax.swing.JLabel labelOrder;
    private javax.swing.JLabel labelOriginalArray;
    private javax.swing.JLabel labelSortedArray;
    private javax.swing.JLabel labelTitle;
    private javax.swing.JTextField txtArrayNums;
    private javax.swing.JTextField txtOriginalArray;
    private javax.swing.JTextField txtSortOrder;
    private javax.swing.JTextField txtSortedArray;
    private javax.swing.JTextField txtSortingAlgorithm;
    // End of variables declaration//GEN-END:variables
}
